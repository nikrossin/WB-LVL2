Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:
```
nil, false

Интерфейс под капотом хранит указатель на таблицу-структуру, которая хранит метаданные о типе и списке методов,
используемых для удовлетворения интерфейсу, а также указатель на объект структуры (статический тип данных).
таблица будет уникальна для каждой пары интерфейс-статический тип, то просчитывать её на этапе компиляции 
будет нерационально и неэффективно. Вместо этого, компилятор генерирует метаданные для каждого статического типа,
в которых, помимо прочего, хранится список методов, реализованных для данного типа.
Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы,
runtime Go может вычислить таблицу  для каждой конкретной пары. Этот таблица кешируется, поэтому просчёт происходит только один раз

пустой интерфейс  — interface{}, ему удовлетворяет вообще любnf, таблицу для него просчитывать и хранить не нужно
достаточно только метаинформации о статическом типе. То есть пустой интерфейс хранит указатель на объект статического
типа и метадные о типе все. ( нет указателя на таблицу).

os.PathError это тип данных, который реализует интерфейс error, возвращаемое значение функции также тип error.
Значение интерфеса состоит из конкретного значения (Что он что-то хранит - объект удовлетворябщего типа) и динамического
значения (по сути значение объекта который храним). Интерфес будет равен nil, если оба его значения nil.
То есть нет ни объекта, который хранимм, ни его значения. Функция возвращает объект типа PathErr со значением nil.
Получется интерфейс имеет уже только динамическое значение nil, а конкретное определено, поэтому первый принт выведет
динамическое значение, а вторый результат false (!=[nil,nil])
```
